## ОСНОВЫ СОПРОГРАММ

### Первая сопрограмма
	
Запустите следующий код:

```kotlin
import kotlinx.coroutines.*

fun main() {
    GlobalScope.launch { // запуск новой сопрограммы в фоне
        delay(1000L) // не-блокируемая задержка в 1 секунду (единица по умолчанию мс)
        println("World!") // печать после задержки
    }
    println("Hello,") // main thread продолжает свою работу во время задержки сопрограммы
    Thread.sleep(2000L) // блокировка main thread на 2 секунды для сохранения работы JVM
}
```

Вы увидите следующий результат:

```text
Hello,
World!
```

Сопрограммы являются облегченными нитями. Запущенные через launch сопрограммы запускаются в контексте CoroutineScope. Здесь мы запускаем сопрограммы в контексте GlobalScope, это означает, что время жизни сопрограммы зависит лишь от времени жизни всего приложения.

Вы сможете добиться такого же результата если замените GlobalScope.launch { ... } с thread { ... } и delay(...) с Thread.sleep(...).

Если вы замените GlobalScope.launch { ... } только с thread { ... }, компилятор выдаст ошибку:

```text
Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function
```

Это связано с тем, что delay - это специальная функция которая не блокирует поток, но приостанавливает сопрограмму, поэтому его можно вызвать только из сопрограмм.

### Соединяем блокирующие с не-блокирующим.
	
В первом же примере не блокирующая задержка delay(...) и блокирующая Thread.sleep(...) используется в одном коде. В этом легко запутаться. Подробно рассмотрим блокировку с использованием компоновщика сопрограмм runBlocking:

```kotlin
import kotlinx.coroutines.*

fun main() { 
    GlobalScope.launch { // запуск новой сопрограммы в фоне
        delay(1000L)
        println("World!")
    }
    println("Hello,") // main thread продолжает свою работу
    runBlocking {     // но это выражение блокирует основной поток
        delay(2000L)  // ... задерживаем на 2 секунды для созранения работы JVM
    } 
}
```

Результат тот же, хотя в этом коде мы используем только не блокирующую задержку. Основная нить блокируется пока выполняется код внутри блока runBlocking.

Этот код может быть переписан более идиометическим способом:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking<Unit> { // запуск основной сопрограммы
    GlobalScope.launch { // запуск новой сопрограммы на фоне
        delay(1000L)
        println("World!")
    }
    println("Hello,") // основная сопрограмма продолжает свою работу
    delay(2000L)      // задержка на 2 секунды для поддержания JVM
}
```

Здесь runBlocking<Unit> { ... } является адаптером для запуска основной сопрограммы верхнего уровня. Мы тут должны яно указать, что тип возвращемого значения Unit, так как main должна возвращать Unit.

Это так же может использоваться для написания приостанавливаемых(suspended) функций для unit тестов:

```kotlin
class MyTest {
    @Test
    fun testMySuspendingFunction() = runBlocking<Unit> {
        // здесь мы можем использовать функции приостановки.
    }
}
```

### Ожидание работы

Задержка на время, пока работет другая сопрограмма не я вляется хорошим подходом. Давайте попробуем подождать пока завершится сопрограмма:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = GlobalScope.launch { // запускаем новую сопрограмму и сохраняем на него ссылку
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    job.join() // ожидаем завершения дочерней сопрограммы
//sampleEnd    
}
```

Результат прежний, но код основной сопрограммы не связан с продолжительностью дочерней.

### Структированнный параллелизм

Когда мы используем GlobalScope.launch, мы создаем сопрограмму высокого уровня. Несмотря, что он довольно легкий он все равно потребляем некоторые ресурсы во время работы. Она запускается если даже мы забыли сохранить ссылку на сопрограмму. Что делать если код в сопрограмме зависает(мы ошибочно поставили слишком большую время ожидания), что делсть если мы запустили слишком много сопрограмм и не хватило памяти? Необходимо вручную сохранять ссылки на все сопрограммы и здесь можно легко ошибиться.

Но есть хорошее решение. Мы сожем использовать структированный параллелизм. Вместо запуска сопрограмм ы GlobalScope, как мы делаем с нитями (нити всегда глобальны), мы можем запустить сопрограммы в конткретной области действия.

В нашем примере у нас есть основная функция, которая превращается в сопрограмму с помощью компоновщика запуска runBlocking. Каждый конструктор сопрограмм, включая runBlocking, добавляет экземпляр CoroutineScope в область своего блока кода. Мы можем запускать сопрограммы в этой области без явного присоединения к ним, потому что внешняя сопрограмма (в нашем примере runBlocking) не завершается, пока не завершатся все сопрограммы, запущенные в ее области действия. Таким образом, мы можем упростить наш пример:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope
    launch { // запускаем новую сопрограмму в рамках runBlocking
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
```

### Создатель областей сопрограмм

В дополнение к области сопрограмм, предоставляемой различными компоновщиками, можно объявить собственную область с помощью компоновщика coroutineScope. Он создает область сопрограммы и не завершается, пока не завершатся все запущенные дочерние элементы. runBlocking и coroutineScope могут выглядеть одинаково, потому что они оба ждут завершения его тела и всех его потомков. Основное различие между этими двумя заключается в том, что метод runBlocking блокирует текущий поток для ожидания, в то время как coroutineScope просто приостанавливает работу, освобождая базовый поток для других применений. Из-за этой разницы runBlocking является обычной функцией, а coroutineScope - функцией приостановки.

Это можно продемонстрировать на следующем примере:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope
    launch { 
        delay(200L)
        println("Задача из runBlocking")
    }
    
    coroutineScope { // Создаем область сопрограммы
        launch {
            delay(500L) 
            println("Задача из вложенного запуска(launch)")
        }
    
        delay(100L)
        println("Задача из области сопрограммы") // Эта строка будет напечатана перед вложенным запуском(launch)
    }
    
    println("Область сопрограммы закончилась") // Эта строка не печатается, пока не завершится вложенный запуск
}
```

Обратите внимание, что сразу после сообщения «Задача из области сопрограмм», ожидая вложенного запуска, «Задача из runBlocking» выполняется и печатается, хотя coroutineScope еще не завершен.

### Получить функции рефакторинга
	
Давайте выделим блок кода внутри launch{...} в отдельную функцию. Когда вы выполняете рефакторинг «Получить функцию» для этого кода, вы получаете новую функцию с модификатором suspend. Это ваша первая функция приостановки. Функции приостановки могут использоваться внутри сопрограмм так же, как обычные функции, но их дополнительная особенность заключается в том, что они, в свою очередь, могут использовать другие функции приостановки, например, задержку в этом примере, чтобы приостановить выполнение сопрограммы.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch { doWorld() }
    println("Hello,")
}

// это ваша первая функция приостановки
suspend fun doWorld() {
    delay(1000L)
    println("World!")
}
```

Но что, если извлеченная функция содержит конструктор сопрограмм, который вызывается в текущей области видимости? В этом случае модификатора suspend на извлеченной функции недостаточно. Создание doWorld в качестве метода расширения в CoroutineScope является одним из решений, но оно не всегда может быть применимо, поскольку не делает API-интерфейс более понятным. Идиоматическим решением является наличие явного CoroutineScope в качестве поля в классе, содержащего целевую функцию, или неявного, когда внешний класс реализует CoroutineScope. В качестве последнего средства можно использовать CoroutineScope (coroutineContext), но такой подход структурно небезопасен, поскольку у вас больше нет контроля над областью выполнения этого метода. Только приватные API могут использовать этот конструктор.

### Сопрограммы очень легкие
	
Запустите следующий код:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    repeat(100_000) { // запускаем 100 000 сопрограмм
        launch {
            delay(1000L)
            print(".")
        }
    }
}
```

Он запускает 100K сопрограмм и через секунду каждая сопрограмма печатает точку. Теперь попробуйте это с нитями. Что случилось бы? (Скорее всего, ваш код выдаст ошибку нехватки памяти)

### Глобальные сопрограммы похожи на нити демонов

Следующий код запускает долгосрочную сопрограмму в GlobalScope, которая печатает «Я сплю» дважды в секунду, а затем через некоторое время возвращается из основной функции:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    GlobalScope.launch {
        repeat(1000) { i ->
            println("Я сплю $i ...")
            delay(500L)
        }
    }
    delay(1300L) // завершается после ожидания
//sampleEnd    
}
```

Вы можете запустить и увидеть, что он печатает три строки и завершается:

```text
Я сплю 0 ...
Я сплю 1 ...
Я сплю 2 ...
```

Активные сопрограммы, запущенные в GlobalScope, не поддерживают процесс. Они как нити демонов.

## ОТМЕНА И ПРИОСТАНОВКА
		
### Отмена сопрограмм
	
В длительно работающем приложении вам может понадобиться детальный контроль над фоновыми сопрограммами. Например, пользователь мог закрыть страницу, которая запустила сопрограмму, и теперь его результат больше не нужен, и его действие можно отменить. Функция запуска возвращает задание, которое можно использовать для отмены запущенной сопрограммы:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        repeat(1000) { i ->
            println(job: Я сплю $i ...")
            delay(500L)
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал от ожидания!")
    job.cancel() // отмена работы
    job.join() // ждем завершения работы
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

Будет следующий результат:

```text
job: Я сплю 0 ...
job: Я сплю 1 ...
job: Я сплю 2 ...
main: Я устал от ожидания!
main: Теперь я могу выйти.
```

Как только main вызывает функцию job.cancel, мы не видим никакого вывода из другой сопрограммы, потому что он был отменен. Существует также функция расширения Job cancelAndJoin, которая объединяет вызовы отмены и ожидания завершения.

### Отмена является кооперативной

Отмена сопрограмм является кооперативной. Код сопрограммы должен сотрудничать, чтобы быть отменяемым. Все приостановленные функции в kotlinx.coroutines отменяются. Они проверяют отмену сопрограммы и выдают CancellationException при отмене. Однако, если сопрограмма работает в вычислении и не проверяет отмену, ее нельзя отменить, как показано в следующем примере:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i < 5) { // вычислительный цикл, просто тратит впустую процессор
            // печатает сообщение дважды в секунду
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: Я сплю ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал от ожидания!")
    job.cancelAndJoin() // отменяет задание и ждет его завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

Запустите его, чтобы увидеть, что он продолжает печатать «Я сплю» даже после отмены, пока задание не завершится само собой после пяти итераций.

### Делаем код отменяемым
	
Существует два подхода к отмене кода вычислений. Первый - периодически вызывать функцию приостановки, которая проверяет отмену. Существует функция выхода, которая является хорошим выбором для этой цели. Другой - явно проверить статус отмены. Давайте попробуем последний подход.

Замените while (i <5) в предыдущем примере на while (isActive) и перезапустите его.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // отменяемый цикл вычислений
            // печатает сообщение дважды в секунду
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: Я сплю ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал от ожидания!")
    job.cancelAndJoin() // отменяет задание и ждет его завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

Как видите, теперь этот цикл отменен. isActive - это свойство расширения, доступное внутри сопрограммы через объект CoroutineScope.

### Закрытие выполнения с помощью finally
	
Отменяемые функции приостановки генерируют исключение CancellationException при отмене, которое может быть обработано обычным способом. Например, выражение try {...} finally {...} и функция использования Kotlin обычно выполняют свои действия завершения при отмене сопрограммы:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i ->
                println("job: Я сплю $i ...")
                delay(500L)
            }
        } finally {
            println("job: Я запустил finally")
        }
    }
    delay(1300L) // Ждем немного
    println("main: Я устал ждать!")
    job.cancelAndJoin() // отменяем задачу и ждем завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

И join, и cancelAndJoin ждут завершения всех действий по завершению, поэтому в приведенном выше примере получаются следующие выходные данные:

```text
job: Я сплю 0 ...
job: Я сплю 1 ...
job: Я сплю 2 ...
main: Я устал ждать!
job: Я запустил finally
main: Теперь я могу выйти.
```

### Запустить не отменяемый блок
	
Любая попытка использовать функцию приостановки в блоке finally предыдущего примера вызывает исключение CancellationException, поскольку сопрограмма, выполняющая этот код, отменяется. Обычно это не проблема, так как все корректные операции закрытия (закрытие файла, отмена задания или закрытие любого канала связи) обычно не блокируют и не включают в себя какие-либо функции приостановки. Однако в редком случае, когда вам нужно приостановить выполнение в отмененной сопрограмме, вы можете заключить соответствующий код в withContext (NonCancellable) {...}, используя функцию withContext и контекст NonCancellable, как показано в следующем примере:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i ->
                println("job: Я сплю $i ...")
                delay(500L)
            }
        } finally {
            withContext(NonCancellable) {
                println("job: Я запускаю finally")
                delay(1000L)
                println("job: И я просто задержался на 1 секунду, потому что я не могу быть отменен")
            }
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал ждать!")
    job.cancelAndJoin() // отменяем задачу и ждем завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

### Приостановка
	
Наиболее очевидная практическая причина отменить выполнение сопрограммы состоит в том, что время ее выполнения превысило некоторое время ожидания. Хотя вы можете вручную отследить ссылку на соответствующее задание и запустить отдельную сопрограмму для отмены отслеживаемой после задержки, есть готовая к использованию функция withTimeout, которая делает это. Посмотрите на следующий пример:

```kotlin
mport kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    withTimeout(1300L) {
        repeat(1000) { i ->
            println("Я сплю $i ...")
            delay(500L)
        }
    }
//sampleEnd
}
```

Он производит следующий вывод:

```text
Я сплю 0 ...
Я сплю 1 ...
Я сплю 2 ...
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
```

TimeoutCancellationException, которое выбрасывается withTimeout, является подклассом CancellationException. Мы не видели его следа стека, напечатанного на консоли раньше. Это связано с тем, что внутри отмененной сопрограммы исключение CancellationException считается нормальной причиной завершения сопрограммы. Однако в этом примере мы использовали withTimeout прямо внутри основной функции.
Поскольку отмена - всего лишь исключение, все ресурсы закрываются обычным способом. Вы можете обернуть код тайм-аутом в блок try {...} catch (e: TimeoutCancellationException) {...}, если вам нужно выполнить какое-то дополнительное действие, особенно в отношении любого типа тайм-аута, или использовать функцию withTimeoutOrNull, которая похожа на withTimeout, но возвращает null по истечении времени ожидания вместо выдачи исключения:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i ->
            println("Я сплю $i ...")
            delay(500L)
        }
        "Done" // будет отменен, прежде чем он даст этот результат
    }
    println("Результат $result")
//sampleEnd
}
```

Больше нет исключения при запуске этого кода:

```text
Я сплю 0 ...
Я сплю 1 ...
Я сплю 2 ...
Результат null
```

## СОЗДАНИЕ ПРИОСТАНОВЛИВАЕМЫХ ФУНКЦИЙ

### Последовательный по умолчанию

Предположим, что у нас есть две функции приостановки, определенные в другом месте, которые делают что-то полезное, например, какой-то вызов удаленного сервиса или вычисления. Мы просто притворяемся, что они полезны, но на самом деле каждый из них просто задерживается на секунду для целей этого примера:

```kotlin
suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь тоже
    return 29
}
```

Что нам делать, если нам нужно, чтобы они вызывались последовательно - сначала doSomethingUsefulOne, а затем doSomethingUsefulTwo и вычислили сумму их результатов? На практике мы делаем это, если мы используем результат первой функции, чтобы принять решение о том, нужно ли нам вызывать вторую или решать, как ее вызывать.

Мы используем обычный последовательный вызов, потому что код в сопрограмме, как и в обычном коде, является последовательным по умолчанию. Следующий пример демонстрирует это, измеряя общее время, необходимое для выполнения обеих функций приостановки:

```kotlin
import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking<Unit> {
//sampleStart
    val time = measureTimeMillis {
        val one = doSomethingUsefulOne()
        val two = doSomethingUsefulTwo()
        println("Ответ ${one + two}")
    }
    println("Завыершено в $time мс")
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь тоже
    return 29
}
```

Вывод:

```text
Ответ 42
Завершено в 2017 мс
```

### Одновременное использование асинхронности(async)

Что если нет никаких зависимостей между вызовами doSomethingUsefulOne и doSomethingUsefulTwo, и мы хотим получить ответ быстрее, выполняя оба одновременно? Здесь асинхронность(async) приходит на помощь.

Концептуально, async - это как launch. Он запускает отдельную сопрограмму, которая представляет собой легкую нить, которая работает одновременно со всеми остальными сопрограммами. Разница в том, что launch возвращает job и не несет никакого результирующего значения, в то время как async возвращает отложенное - легкое неблокирующее будущее, которое представляет обещание предоставить результат позже. Вы можете использовать .await () для отложенного значения, чтобы получить возможный результат, но отложенное(Deferred) также является заданием, поэтому вы можете отменить его, если это необходимо.

```kotlin
import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking<Unit> {
//sampleStart
    val time = measureTimeMillis {
        val one = async { doSomethingUsefulOne() }
        val two = async { doSomethingUsefulTwo() }
        println("Ответ ${one.await() + two.await()}")
    }
    println("Завершено в $time мс")
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь тоже
    return 29
}
```

Вывод:

```text
Ответ 42
Завершено в 1017 мс
```

Это в два раза быстрее, потому что две сопрограммы выполняются одновременно. Обратите внимание, что параллелизм с сопрограммами всегда явный.

### Ленивый запуск async

При желании async можно сделать ленивой, установив для ее параметра запуска значение CoroutineStart.LAZY. В этом режиме он запускает сопрограмму только тогда, когда потребуется его результат или если вызывается функция запуска его задания. Запустите следующий пример:

```kotlin
import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking<Unit> {
//sampleStart
    val time = measureTimeMillis {
        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }
        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }
        // некоторые вычисления
        one.start() // запускаем первый
        two.start() // запускаем второй
        println("Ответ ${one.await() + two.await()}")
    }
    println("Завершено в $time мс")
//sampleEnd    
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // притвориться, что мы делаем что-то полезное здесь тоже
    return 29
}
```

Вывод:

```text
Ответ 42
Завершено в 1017 мс
```

Итак, здесь две сопрограммы определены, но не выполнены, как в предыдущем примере, но управление предоставляется программисту, когда именно начинать выполнение, вызывая start. Сначала мы запускаем один, затем запускаем второй, а затем ожидаем окончания отдельных сопрограмм.

Обратите внимание, что если мы просто вызовем await в println без первого вызова start для отдельных сопрограмм, это приведет к последовательному поведению, поскольку await начинает выполнение сопрограммы и ожидает его завершения, что не является предполагаемым вариантом использования для ленивого запуска. Вариант использования async (start = CoroutineStart.LAZY) является заменой стандартной функции lazy в случаях, когда вычисление значения включает в себя приостановку функций.

### Асинхронные функции

Мы можем определить функции асинхронного стиля, которые будут вызывать doSomethingUsefulOne и doSomethingUsefulTwo асинхронно, используя асинхронный конструктор сопрограмм с явной ссылкой GlobalScope. Мы называем такие функции суффиксом "... Async", чтобы подчеркнуть тот факт, что они только запускают асинхронные вычисления, и для получения результата необходимо использовать полученное отложенное значение.

```kotlin
// Тип результата somethingUsefulOneAsync Deferred<Int>
fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

// Тип результата somethingUsefulTwoAsync Deferred<Int>
fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}
```

Обратите внимание, что эти функции xxxAsync не являются функциями приостановки. Их можно использовать откуда угодно. Однако их использование всегда подразумевает асинхронное (здесь означает одновременное) выполнение их действия с вызывающим кодом.

В следующем примере показано их использование вне сопрограммы:

```kotlin
//sampleStart
// обратите внимание, что у нас нет `runBlocking` справа от` main` в этом примере
fun main() {
    val time = measureTimeMillis {
        // мы можем инициировать асинхронные действия вне сопрограммы
        val one = somethingUsefulOneAsync()
        val two = somethingUsefulTwoAsync()
        // но ожидание результата должно включать либо приостановку, либо блокировку.
        // здесь мы используем `runBlocking {...}`, чтобы заблокировать основной поток в ожидании результата
        runBlocking {
            println("The answer is ${one.await() + two.await()}")
        }
    }
    println("Completed in $time ms")
}
//sampleEnd

fun somethingUsefulOneAsync() = GlobalScope.async {
    doSomethingUsefulOne()
}

fun somethingUsefulTwoAsync() = GlobalScope.async {
    doSomethingUsefulTwo()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // притворись, что мы делаем что-то полезное здесь
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // притворись, что мы делаем что-то полезное и здесь
    return 29
}
```

Этот стиль программирования с асинхронными функциями представлен здесь только для иллюстрации, потому что это популярный стиль в других языках программирования. Использование этого стиля с сопрограммами Kotlin настоятельно не рекомендуется по причинам, объясненным ниже.

Рассмотрим, что произойдет, если между строкой val one = somethingUsefulOneAsync () и выражением one.await () в коде будет какая-то логическая ошибка, и программа сгенерирует исключение, и операция, выполняемая программой, будет прервана. Обычно глобальный обработчик ошибок может перехватить это исключение, зарегистрировать и сообщить об ошибке разработчикам, но в противном случае программа может продолжить выполнение других операций. Но здесь у нас есть кое-что UseOneAsync, все еще работающее в фоновом режиме, хотя инициирующая его операция была прервана. Эта проблема не возникает со структурированным параллелизмом, как показано в разделе ниже.

### Структурный параллелизм с асинхронностью

Давайте возьмем пример конкурент с использованием асинхронности и создадим функцию, которая одновременно выполняет doSomethingUsefulOne и doSomethingUsefulTwo и возвращает сумму их результатов. Поскольку асинхронный конструктор сопрограмм определен как расширение в CoroutineScope, нам необходимо иметь его в области видимости, и именно это обеспечивает функция coroutineScope:

```kotlin
suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}
```

Таким образом, если что-то пойдет не так в коде функции concurrentSum и он выдаст исключение, все сопрограммы, запущенные в его области действия, будут отменены.

```kotlin
import kotlinx.coroutines.*
import kotlin.system.*

fun main() = runBlocking<Unit> {
//sampleStart
    val time = measureTimeMillis {
        println("Ответ ${concurrentSum()}")
    }
    println("Завершено в $time мс")
//sampleEnd    
}

suspend fun concurrentSum(): Int = coroutineScope {
    val one = async { doSomethingUsefulOne() }
    val two = async { doSomethingUsefulTwo() }
    one.await() + two.await()
}

suspend fun doSomethingUsefulOne(): Int {
    delay(1000L) // притворись, что мы делаем что-то полезное здесь
    return 13
}

suspend fun doSomethingUsefulTwo(): Int {
    delay(1000L) // притворись, что мы делаем что-то полезное и здесь
    return 29
}
```

У нас все еще происходит одновременное выполнение обеих операций, как видно из вывода вышеуказанной основной функции:

```text
Ответ 42
Завершено в 1017 мс
```

Отмена всегда распространяется через иерархию сопрограмм:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking<Unit> {
    try {
        failedConcurrentSum()
    } catch(e: ArithmeticException) {
        println("Вычисление прервалось с ArithmeticException")
    }
}

suspend fun failedConcurrentSum(): Int = coroutineScope {
    val one = async<Int> { 
        try {
            delay(Long.MAX_VALUE) // Эмулирует очень длинные вычисления
            42
        } finally {
            println("Первая дочерняя была отменена")
        }
    }
    val two = async<Int> { 
        println("Вторая дочерняя сбросила исключение")
        throw ArithmeticException()
    }
    one.await() + two.await()
}
```

Обратите внимание, как и первый async, и ожидающий родитель отменяются при сбое одного из дочерних элементов (а именно, двух):

```text
Вторая дочерняя сбросила исключение
Первая дочерняя была отменена
Вычисление прервалось с ArithmeticException
```

