## ОСНОВЫ СОПРОГРАММ

### Первая сопрограмма
	
Запустите следующий код:

```kotlin
import kotlinx.coroutines.*

fun main() {
    GlobalScope.launch { // запуск новой сопрограммы в фоне
        delay(1000L) // не-блокируемая задержка в 1 секунду (единица по умолчанию мс)
        println("World!") // печать после задержки
    }
    println("Hello,") // main thread продолжает свою работу во время задержки сопрограммы
    Thread.sleep(2000L) // блокировка main thread на 2 секунды для сохранения работы JVM
}
```

Вы увидите следующий результат:

```text
Hello,
World!
```

Сопрограммы являются облегченными нитями. Запущенные через launch сопрограммы запускаются в контексте CoroutineScope. Здесь мы запускаем сопрограммы в контексте GlobalScope, это означает, что время жизни сопрограммы зависит лишь от времени жизни всего приложения.

Вы сможете добиться такого же результата если замените GlobalScope.launch { ... } с thread { ... } и delay(...) с Thread.sleep(...).

Если вы замените GlobalScope.launch { ... } только с thread { ... }, компилятор выдаст ошибку:

```text
Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function
```

Это связано с тем, что delay - это специальная функция которая не блокирует поток, но приостанавливает сопрограмму, поэтому его можно вызвать только из сопрограмм.

### Соединяем блокирующие с не-блокирующим.
	
В первом же примере не блокирующая задержка delay(...) и блокирующая Thread.sleep(...) используется в одном коде. В этом легко запутаться. Подробно рассмотрим блокировку с использованием компоновщика сопрограмм runBlocking:

```kotlin
import kotlinx.coroutines.*

fun main() { 
    GlobalScope.launch { // запуск новой сопрограммы в фоне
        delay(1000L)
        println("World!")
    }
    println("Hello,") // main thread продолжает свою работу
    runBlocking {     // но это выражение блокирует основной поток
        delay(2000L)  // ... задерживаем на 2 секунды для созранения работы JVM
    } 
}
```

Результат тот же, хотя в этом коде мы используем только не блокирующую задержку. Основная нить блокируется пока выполняется код внутри блока runBlocking.

Этот код может быть переписан более идиометическим способом:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking<Unit> { // запуск основной сопрограммы
    GlobalScope.launch { // запуск новой сопрограммы на фоне
        delay(1000L)
        println("World!")
    }
    println("Hello,") // основная сопрограмма продолжает свою работу
    delay(2000L)      // задержка на 2 секунды для поддержания JVM
}
```

Здесь runBlocking<Unit> { ... } является адаптером для запуска основной сопрограммы верхнего уровня. Мы тут должны яно указать, что тип возвращемого значения Unit, так как main должна возвращать Unit.

Это так же может использоваться для написания приостанавливаемых(suspended) функций для unit тестов:

```kotlin
class MyTest {
    @Test
    fun testMySuspendingFunction() = runBlocking<Unit> {
        // здесь мы можем использовать функции приостановки.
    }
}
```

### Ожидание работы

Задержка на время, пока работет другая сопрограмма не я вляется хорошим подходом. Давайте попробуем подождать пока завершится сопрограмма:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = GlobalScope.launch { // запускаем новую сопрограмму и сохраняем на него ссылку
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    job.join() // ожидаем завершения дочерней сопрограммы
//sampleEnd    
}
```

Результат прежний, но код основной сопрограммы не связан с продолжительностью дочерней.

### Структированнный параллелизм

Когда мы используем GlobalScope.launch, мы создаем сопрограмму высокого уровня. Несмотря, что он довольно легкий он все равно потребляем некоторые ресурсы во время работы. Она запускается если даже мы забыли сохранить ссылку на сопрограмму. Что делать если код в сопрограмме зависает(мы ошибочно поставили слишком большую время ожидания), что делсть если мы запустили слишком много сопрограмм и не хватило памяти? Необходимо вручную сохранять ссылки на все сопрограммы и здесь можно легко ошибиться.

Но есть хорошее решение. Мы сожем использовать структированный параллелизм. Вместо запуска сопрограмм ы GlobalScope, как мы делаем с нитями (нити всегда глобальны), мы можем запустить сопрограммы в конткретной области действия.

В нашем примере у нас есть основная функция, которая превращается в сопрограмму с помощью компоновщика запуска runBlocking. Каждый конструктор сопрограмм, включая runBlocking, добавляет экземпляр CoroutineScope в область своего блока кода. Мы можем запускать сопрограммы в этой области без явного присоединения к ним, потому что внешняя сопрограмма (в нашем примере runBlocking) не завершается, пока не завершатся все сопрограммы, запущенные в ее области действия. Таким образом, мы можем упростить наш пример:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope
    launch { // запускаем новую сопрограмму в рамках runBlocking
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
```

### Создатель областей сопрограмм

В дополнение к области сопрограмм, предоставляемой различными компоновщиками, можно объявить собственную область с помощью компоновщика coroutineScope. Он создает область сопрограммы и не завершается, пока не завершатся все запущенные дочерние элементы. runBlocking и coroutineScope могут выглядеть одинаково, потому что они оба ждут завершения его тела и всех его потомков. Основное различие между этими двумя заключается в том, что метод runBlocking блокирует текущий поток для ожидания, в то время как coroutineScope просто приостанавливает работу, освобождая базовый поток для других применений. Из-за этой разницы runBlocking является обычной функцией, а coroutineScope - функцией приостановки.

Это можно продемонстрировать на следующем примере:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope
    launch { 
        delay(200L)
        println("Задача из runBlocking")
    }
    
    coroutineScope { // Создаем область сопрограммы
        launch {
            delay(500L) 
            println("Задача из вложенного запуска(launch)")
        }
    
        delay(100L)
        println("Задача из области сопрограммы") // Эта строка будет напечатана перед вложенным запуском(launch)
    }
    
    println("Область сопрограммы закончилась") // Эта строка не печатается, пока не завершится вложенный запуск
}
```

Обратите внимание, что сразу после сообщения «Задача из области сопрограмм», ожидая вложенного запуска, «Задача из runBlocking» выполняется и печатается, хотя coroutineScope еще не завершен.

### Получить функции рефакторинга
	
Давайте выделим блок кода внутри launch{...} в отдельную функцию. Когда вы выполняете рефакторинг «Получить функцию» для этого кода, вы получаете новую функцию с модификатором suspend. Это ваша первая функция приостановки. Функции приостановки могут использоваться внутри сопрограмм так же, как обычные функции, но их дополнительная особенность заключается в том, что они, в свою очередь, могут использовать другие функции приостановки, например, задержку в этом примере, чтобы приостановить выполнение сопрограммы.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch { doWorld() }
    println("Hello,")
}

// это ваша первая функция приостановки
suspend fun doWorld() {
    delay(1000L)
    println("World!")
}
```

Но что, если извлеченная функция содержит конструктор сопрограмм, который вызывается в текущей области видимости? В этом случае модификатора suspend на извлеченной функции недостаточно. Создание doWorld в качестве метода расширения в CoroutineScope является одним из решений, но оно не всегда может быть применимо, поскольку не делает API-интерфейс более понятным. Идиоматическим решением является наличие явного CoroutineScope в качестве поля в классе, содержащего целевую функцию, или неявного, когда внешний класс реализует CoroutineScope. В качестве последнего средства можно использовать CoroutineScope (coroutineContext), но такой подход структурно небезопасен, поскольку у вас больше нет контроля над областью выполнения этого метода. Только приватные API могут использовать этот конструктор.

### Сопрограммы очень легкие
	
Запустите следующий код:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    repeat(100_000) { // запускаем 100 000 сопрограмм
        launch {
            delay(1000L)
            print(".")
        }
    }
}
```

Он запускает 100K сопрограмм и через секунду каждая сопрограмма печатает точку. Теперь попробуйте это с нитями. Что случилось бы? (Скорее всего, ваш код выдаст ошибку нехватки памяти)

### Глобальные сопрограммы похожи на нити демонов

Следующий код запускает долгосрочную сопрограмму в GlobalScope, которая печатает «Я сплю» дважды в секунду, а затем через некоторое время возвращается из основной функции:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    GlobalScope.launch {
        repeat(1000) { i ->
            println("Я сплю $i ...")
            delay(500L)
        }
    }
    delay(1300L) // завершается после ожидания
//sampleEnd    
}
```

Вы можете запустить и увидеть, что он печатает три строки и завершается:

```text
Я сплю 0 ...
Я сплю 1 ...
Я сплю 2 ...
```

Активные сопрограммы, запущенные в GlobalScope, не поддерживают процесс. Они как нити демонов.

## ОТМЕНА И ПРИОСТАНОВКА
		
### Отмена сопрограмм
	
В длительно работающем приложении вам может понадобиться детальный контроль над фоновыми сопрограммами. Например, пользователь мог закрыть страницу, которая запустила сопрограмму, и теперь его результат больше не нужен, и его действие можно отменить. Функция запуска возвращает задание, которое можно использовать для отмены запущенной сопрограммы:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        repeat(1000) { i ->
            println(job: Я сплю $i ...")
            delay(500L)
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал от ожидания!")
    job.cancel() // отмена работы
    job.join() // ждем завершения работы
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

Будет следующий результат:

```text
job: Я сплю 0 ...
job: Я сплю 1 ...
job: Я сплю 2 ...
main: Я устал от ожидания!
main: Теперь я могу выйти.
```

Как только main вызывает функцию job.cancel, мы не видим никакого вывода из другой сопрограммы, потому что он был отменен. Существует также функция расширения Job cancelAndJoin, которая объединяет вызовы отмены и ожидания завершения.

### Отмена является кооперативной

Отмена сопрограмм является кооперативной. Код сопрограммы должен сотрудничать, чтобы быть отменяемым. Все приостановленные функции в kotlinx.coroutines отменяются. Они проверяют отмену сопрограммы и выдают CancellationException при отмене. Однако, если сопрограмма работает в вычислении и не проверяет отмену, ее нельзя отменить, как показано в следующем примере:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (i < 5) { // вычислительный цикл, просто тратит впустую процессор
            // печатает сообщение дважды в секунду
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: Я сплю ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал от ожидания!")
    job.cancelAndJoin() // отменяет задание и ждет его завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

Запустите его, чтобы увидеть, что он продолжает печатать «Я сплю» даже после отмены, пока задание не завершится само собой после пяти итераций.

### Делаем код отменяемым
	
Существует два подхода к отмене кода вычислений. Первый - периодически вызывать функцию приостановки, которая проверяет отмену. Существует функция выхода, которая является хорошим выбором для этой цели. Другой - явно проверить статус отмены. Давайте попробуем последний подход.

Замените while (i <5) в предыдущем примере на while (isActive) и перезапустите его.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // отменяемый цикл вычислений
            // печатает сообщение дважды в секунду
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: Я сплю ${i++} ...")
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал от ожидания!")
    job.cancelAndJoin() // отменяет задание и ждет его завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

Как видите, теперь этот цикл отменен. isActive - это свойство расширения, доступное внутри сопрограммы через объект CoroutineScope.

### Закрытие выполнения с помощью finally
	
Отменяемые функции приостановки генерируют исключение CancellationException при отмене, которое может быть обработано обычным способом. Например, выражение try {...} finally {...} и функция использования Kotlin обычно выполняют свои действия завершения при отмене сопрограммы:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i ->
                println("job: Я сплю $i ...")
                delay(500L)
            }
        } finally {
            println("job: Я запустил finally")
        }
    }
    delay(1300L) // Ждем немного
    println("main: Я устал ждать!")
    job.cancelAndJoin() // отменяем задачу и ждем завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

И join, и cancelAndJoin ждут завершения всех действий по завершению, поэтому в приведенном выше примере получаются следующие выходные данные:

```text
job: Я сплю 0 ...
job: Я сплю 1 ...
job: Я сплю 2 ...
main: Я устал ждать!
job: Я запустил finally
main: Теперь я могу выйти.
```

### Запустить не отменяемый блок
	
Любая попытка использовать функцию приостановки в блоке finally предыдущего примера вызывает исключение CancellationException, поскольку сопрограмма, выполняющая этот код, отменяется. Обычно это не проблема, так как все корректные операции закрытия (закрытие файла, отмена задания или закрытие любого канала связи) обычно не блокируют и не включают в себя какие-либо функции приостановки. Однако в редком случае, когда вам нужно приостановить выполнение в отмененной сопрограмме, вы можете заключить соответствующий код в withContext (NonCancellable) {...}, используя функцию withContext и контекст NonCancellable, как показано в следующем примере:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val job = launch {
        try {
            repeat(1000) { i ->
                println("job: Я сплю $i ...")
                delay(500L)
            }
        } finally {
            withContext(NonCancellable) {
                println("job: Я запускаю finally")
                delay(1000L)
                println("job: И я просто задержался на 1 секунду, потому что я не могу быть отменен")
            }
        }
    }
    delay(1300L) // ждем немного
    println("main: Я устал ждать!")
    job.cancelAndJoin() // отменяем задачу и ждем завершения
    println("main: Теперь я могу выйти.")
//sampleEnd    
}
```

### Приостановка
	
Наиболее очевидная практическая причина отменить выполнение сопрограммы состоит в том, что время ее выполнения превысило некоторое время ожидания. Хотя вы можете вручную отследить ссылку на соответствующее задание и запустить отдельную сопрограмму для отмены отслеживаемой после задержки, есть готовая к использованию функция withTimeout, которая делает это. Посмотрите на следующий пример:

```kotlin
mport kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    withTimeout(1300L) {
        repeat(1000) { i ->
            println("Я сплю $i ...")
            delay(500L)
        }
    }
//sampleEnd
}
```

Он производит следующий вывод:

```text
Я сплю 0 ...
Я сплю 1 ...
Я сплю 2 ...
Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
```

TimeoutCancellationException, которое выбрасывается withTimeout, является подклассом CancellationException. Мы не видели его следа стека, напечатанного на консоли раньше. Это связано с тем, что внутри отмененной сопрограммы исключение CancellationException считается нормальной причиной завершения сопрограммы. Однако в этом примере мы использовали withTimeout прямо внутри основной функции.
Поскольку отмена - всего лишь исключение, все ресурсы закрываются обычным способом. Вы можете обернуть код тайм-аутом в блок try {...} catch (e: TimeoutCancellationException) {...}, если вам нужно выполнить какое-то дополнительное действие, особенно в отношении любого типа тайм-аута, или использовать функцию withTimeoutOrNull, которая похожа на withTimeout, но возвращает null по истечении времени ожидания вместо выдачи исключения:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
//sampleStart
    val result = withTimeoutOrNull(1300L) {
        repeat(1000) { i ->
            println("Я сплю $i ...")
            delay(500L)
        }
        "Done" // будет отменен, прежде чем он даст этот результат
    }
    println("Результат $result")
//sampleEnd
}
```

Больше нет исключения при запуске этого кода:

```text
Я сплю 0 ...
Я сплю 1 ...
Я сплю 2 ...
Результат null
```

